PAHANA EDU BOOKSHOP SYSTEM - COMPREHENSIVE TECHNICAL REPORT
================================================================

1. INTRODUCTION
===============

1.1 Scenario Recap
------------------
The Pahana Edu Bookshop is a comprehensive web-based billing and inventory management system for a physical bookshop located in Colombo, Sri Lanka. The system serves both customers and administrators, providing complete book catalog management, customer registration, shopping cart functionality, order processing, and administrative oversight.

1.2 Objectives
--------------
- Provide a modern web-based interface for book browsing and purchasing
- Enable customer account management and order tracking
- Offer comprehensive administrative tools for inventory and customer management
- Support secure authentication and role-based access control
- Generate PDF bills and maintain complete order history
- Facilitate both guest and registered user purchases

2. SYSTEM ANALYSIS & DESIGN
===========================

2.1 Use Case Diagrams
---------------------
The system supports the following primary use cases:

**Customer Use Cases:**
- Browse book catalog with filtering and search
- Create user account and manage profile
- Add books to shopping cart
- Complete checkout process (guest or registered)
- View order history and track orders
- Download PDF bills

**Admin Use Cases:**
- Manage book inventory (add, edit, delete books)
- View and manage customer accounts
- Process and track orders
- Generate reports and view dashboard statistics
- Manage system users and roles

**System Use Cases:**
- Authenticate users with Spring Security
- Initialize sample data on startup
- Validate form inputs and business rules
- Generate unique bill numbers and PDFs

2.2 Class Diagrams
------------------
The system implements a layered architecture with the following class hierarchy:

**Model Layer (4 core entities):**
- User: Authentication and authorization entity
- Customer: Customer information and order history
- Item: Book/product catalog entity
- Bill: Order and billing information with nested OrderItem class

**Repository Layer (4 interfaces):**
- UserRepository: User data access with custom queries
- CustomerRepository: Customer CRUD and search operations
- ItemRepository: Book inventory management with category filtering
- BillRepository: Order and billing data persistence

**Service Layer (3 business logic classes):**
- UserService: User management and Spring Security integration
- CustomerService: Customer operations and order processing
- ItemService: Inventory management and sample data initialization

**Controller Layer (6+ web controllers):**
- HomeController: Public pages (home, shop, help)
- AuthController: Login and registration functionality
- AdminController: Administrative interface and operations
- CustomerController: Customer management and API endpoints
- Plus additional API controllers for AJAX operations

**Configuration Layer (3 configuration classes):**
- SecurityConfig: Spring Security setup and access rules
- AppConfig: General application configuration
- DataInitializer: Startup data initialization and database setup

2.3 Sequence Diagrams
---------------------
**User Registration Flow:**
1. User submits registration form → AuthController
2. AuthController validates input → UserService
3. UserService checks username/phone uniqueness → UserRepository
4. UserService encrypts password → BCryptPasswordEncoder
5. UserService creates User entity → UserRepository
6. UserService creates associated Customer → CustomerService
7. System redirects to login page

**Book Purchase Flow:**
1. User adds books to cart → JavaScript localStorage
2. User proceeds to checkout → HomeController
3. System collects customer information → CustomerController
4. CustomerController validates and creates Customer → CustomerService
5. CustomerService creates Bill with OrderItems → BillRepository
6. System generates PDF bill → iText library
7. System updates customer statistics → CustomerService

**Admin Inventory Management:**
1. Admin accesses items page → AdminController (requires ADMIN role)
2. AdminController loads book list → ItemRepository
3. Admin adds/edits book → AdminController validates form
4. AdminController saves Item → ItemRepository
5. System updates category list → ItemService

2.4 System Implementation
-------------------------

**Architecture Overview:**
- Model-View-Controller (MVC) pattern with Spring Boot
- Layered architecture: Presentation → Business → Data Access
- Dependency injection throughout all layers
- RESTful API endpoints for AJAX operations

**Key Technologies Integration:**
- Spring Boot 3.2.5 as main application framework
- Spring Security for authentication and authorization
- Spring Data MongoDB for data persistence
- Thymeleaf for server-side templating
- Bootstrap 5.3.0 for responsive UI framework
- JavaScript ES6+ for client-side interactivity

3. DESIGN PATTERNS IN CONTEXT
=============================

3.1 Model-View-Controller (MVC)
-------------------------------
**Implementation:**
- Model: Item, Customer, User, Bill entities with validation annotations
- View: Thymeleaf templates in src/main/resources/pages/
- Controller: Spring @Controller classes handling HTTP requests

**Example - Shop Page:**
- Model: List<Item> items passed to template
- View: shop.html with Thymeleaf expressions for dynamic content
- Controller: HomeController.shop() method with filtering logic

3.2 Factory Method
------------------
**Implementation:**
- OrderItem creation in Bill.addItem() method
- Sample data creation in ItemService.initializeSampleData()
- PDF generation through iText document factory

3.3 Repository Pattern
----------------------
**Implementation:**
- Spring Data MongoDB repositories extending MongoRepository
- Custom query methods like findByCategory(), findByTitleContaining()
- Abstraction of data access from business logic

3.4 Strategy Pattern
-------------------
**Implementation:**
- Payment method handling in Bill entity (CASH, CARD, BANK_TRANSFER)
- User authentication strategies in SecurityConfig
- Category filtering strategies in ItemService

3.5 Singleton Pattern
--------------------
**Implementation:**
- Spring beans managed as singletons by default
- Configuration classes like SecurityConfig, AppConfig
- Service layer instances injected throughout application

4. ARCHITECTURE OVERVIEW - 4 TIER WITH API GATEWAY
==================================================

4.1 Presentation Tier - Spring API Gateway
------------------------------------------
**Technology:** Spring Boot with embedded Tomcat
**Components:**
- Thymeleaf template engine for server-side rendering
- Bootstrap 5.3.0 for responsive design
- Font Awesome 6.4.0 for icons
- Custom CSS with modern design system
- JavaScript ES6+ for client interactions

**Security Integration:**
- Spring Security filter chain for request authentication
- CSRF protection for form submissions
- Role-based access control (USER, ADMIN roles)
- Session management with secure cookies

4.2 Integration Tier - Spring Boot RESTful APIs
-----------------------------------------------
**REST Controllers:**
- HomeController: Public endpoints (/shop, /help, /cart)
- AuthController: Authentication endpoints (/login, /register)
- AdminController: Administrative APIs (/admin/*)
- CustomerController: Customer and billing APIs (/customers/api/*)

**API Features:**
- JSON response format for AJAX calls
- RESTful URL conventions
- Proper HTTP status codes
- Request/response validation

4.3 Domain Logic Tier - Spring Boot Applications
------------------------------------------------
**Business Services:**
- UserService: User management and Spring Security integration
- CustomerService: Customer operations and order processing
- ItemService: Inventory management and data initialization

**Business Rules:**
- User registration with unique username/phone validation
- Order processing with automatic bill generation
- Category migration for existing inventory
- PDF bill generation with iText library

**Transaction Management:**
- MongoDB transactions for order processing
- Automatic rollback on processing failures
- Data consistency across related entities

4.4 Database Tier - Data Stores and Services
--------------------------------------------
**Primary Database:** MongoDB Atlas (Cloud)
- Connection: mongodb+srv://[credentials]@cluster.mongodb.net/pahana_edu_db
- Collections: users, customers, items, bills
- Indexing: Automatic indexing disabled, custom indexes created

**Data Models:**
- User: Authentication and role management
- Customer: Personal information and order history
- Item: Book catalog with categories (Novels, History, Scifi, Educational, Children's)
- Bill: Order processing with nested OrderItem structure

**Data Persistence:**
- Spring Data MongoDB for repository pattern
- Embedded documents for OrderItem within Bill
- DBRef relationships between entities
- Automatic timestamp management

5. TESTING STRATEGY
===================

5.1 TDD Workflow in Practice
----------------------------
**Test Structure:**
- JUnit 5 for unit testing framework
- Mockito for mocking dependencies
- Spring Boot Test for integration testing
- TestContainers for MongoDB testing

**Test Categories:**
- Unit Tests: Service layer business logic
- Integration Tests: Controller and repository interactions
- Security Tests: Authentication and authorization flows

**Current Test Files:**
- PahanaEduApplicationTests.java: Basic application context testing
- AuthControllerTest.java: Authentication endpoint testing
- TestMongoConfig.java: Test database configuration

5.2 Automation Pipeline
-----------------------
**Build Configuration:**
- Maven Surefire Plugin for test execution
- JaCoCo for code coverage reporting
- Checkstyle for code quality validation
- Maven compiler plugin with Java 23 support

**Test Execution:**
- mvn test: Run all unit and integration tests
- mvn jacoco:report: Generate coverage reports
- mvn checkstyle:check: Validate code standards

5.3 Authentication Pipeline
---------------------------
**Spring Security Configuration:**
- BCrypt password encoding for secure password storage
- Session-based authentication with remember-me functionality
- Role-based authorization with method-level security
- Custom UserDetailsService implementation

**Security Testing:**
- @WithMockUser annotations for security context testing
- CSRF token validation in form submissions
- Access denied page configuration for unauthorized access

5.4 Results & Metrics
---------------------
**Test Coverage:** Unit tests cover core business logic
**Performance:** Application startup optimization with lazy loading
**Security:** Role-based access control with encrypted passwords
**Reliability:** Error handling and validation throughout system

6. CONCLUDING SUMMARY
=====================

6.1 Database Schema Rationale
-----------------------------
**MongoDB Collections:**

**users Collection:**
- id: ObjectId primary key
- username: Unique identifier for login
- phone: Alternative login method with validation
- password: BCrypt encrypted password
- role: USER or ADMIN for authorization
- enabled: Account status flag

**customers Collection:**
- id: ObjectId primary key
- firstName, lastName: Personal identification
- email: Communication and backup identification
- phoneNumber: Primary contact method
- address, city, postalCode: Shipping information
- registrationDate: Account creation timestamp
- totalSpent, totalOrders: Business metrics
- orderHistory: Array of Bill references

**items Collection:**
- id: ObjectId primary key
- title, author: Book identification
- description: Detailed book information
- price: Monetary value with validation
- category: Book classification (Novels, History, Scifi, Educational, Children's)
- isbn, publisher, publishYear: Publishing details
- available: Stock status flag

**bills Collection:**
- id: ObjectId primary key
- billNumber: Human-readable order reference
- customer: DBRef to customer document
- items: Array of embedded OrderItem documents
- subtotal, taxAmount, totalAmount: Financial calculations
- paymentMethod, paymentStatus: Payment tracking
- orderStatus: Fulfillment tracking
- orderDate, deliveryDate: Timeline management

6.2 Security & Authentication
-----------------------------
**Implementation Details:**
- Spring Security with form-based authentication
- BCrypt password hashing with salt
- Session management with secure cookies
- CSRF protection for all forms
- Role-based access control with @PreAuthorize annotations

**Access Control Matrix:**
- Public access: /, /shop, /help, /register, /login, static resources
- User access: /user/**, /my-orders, /profile
- Admin access: /admin/** with ADMIN role requirement
- API endpoints: Protected based on functionality

6.3 Lessons Learned
-------------------
**Technical Achievements:**
- Successful integration of Spring Boot 3.2.5 with Java 23
- Effective use of MongoDB for document-based data storage
- Implementation of modern UI with Bootstrap and custom CSS
- Comprehensive security implementation with Spring Security

**Development Best Practices:**
- Layered architecture with clear separation of concerns
- Dependency injection throughout the application
- Validation annotations for data integrity
- Error handling with user-friendly feedback

**Business Logic Implementation:**
- Dynamic category system with migration capability
- Flexible order processing supporting guest and registered users
- PDF generation for professional billing
- Real-time cart management with localStorage

**Future Enhancement Opportunities:**
- Email notification system for order updates
- Advanced search with full-text indexing
- Mobile application API endpoints
- Analytics dashboard for business intelligence
- Inventory management with low stock alerts

The Pahana Edu Bookshop system successfully demonstrates modern web application development using Spring Boot ecosystem, providing a complete solution for bookshop management with robust security, user-friendly interface, and comprehensive business functionality.
